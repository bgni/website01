type ThumbFormat = "png" | "jpg" | "both";

const quote = (value: string) => JSON.stringify(value);

const slugToFileBase = (mfg: string, modelFileBase: string): string =>
  `${String(mfg).toLowerCase()}-${String(modelFileBase).toLowerCase()}`
    .replace(/[^a-z0-9\-]+/g, "-")
    .replace(/\-+/g, "-")
    .replace(/(^-|-$)/g, "");

const computeCandidateThumbs = (
  deviceTypeSlug: string,
): { thumbPng: string; thumbJpg: string } | null => {
  const slug = deviceTypeSlug.trim();
  if (!slug || !slug.includes("/")) return null;
  const parts = slug.split("/");
  if (parts.length !== 2) return null;
  const [mfg, modelFileBase] = parts;
  if (!mfg || !modelFileBase) return null;
  const fileBase = slugToFileBase(mfg, modelFileBase);
  if (!fileBase) return null;
  const base =
    `vendor/netbox-devicetype-library/elevation-images/${mfg}/${fileBase}.front`;
  return { thumbPng: `${base}.png`, thumbJpg: `${base}.jpg` };
};

const exists = async (path: string): Promise<boolean> => {
  try {
    await Deno.stat(path);
    return true;
  } catch {
    return false;
  }
};

if (import.meta.main) {
  const indexPath = Deno.args[0] ?? "data/netbox-device-types.json";
  const outPath = Deno.args[1] ??
    "scripts/domain/netboxElevationAvailability.ts";

  const raw = JSON.parse(await Deno.readTextFile(indexPath)) as {
    items?: Record<string, unknown>;
  };
  const slugs = Object.keys(raw.items ?? {}).sort((left, right) =>
    left.localeCompare(right)
  );

  const availableBySlug = new Map<string, ThumbFormat>();

  for (const slug of slugs) {
    const candidate = computeCandidateThumbs(slug);
    if (!candidate) continue;
    const pngPath = candidate.thumbPng;
    const jpgPath = candidate.thumbJpg;
    const hasPng = typeof pngPath === "string" && pngPath
      ? await exists(pngPath)
      : false;
    const hasJpg = typeof jpgPath === "string" && jpgPath
      ? await exists(jpgPath)
      : false;
    if (hasPng && hasJpg) {
      availableBySlug.set(slug, "both");
    } else if (hasPng) {
      availableBySlug.set(slug, "png");
    } else if (hasJpg) {
      availableBySlug.set(slug, "jpg");
    }
  }

  let source =
    "// Generated by `deno run --allow-read --allow-write tools/build_elevation_availability.ts`\n";
  source +=
    'export const NETBOX_ELEVATION_FORMAT_BY_SLUG: Record<string, "png" | "jpg" | "both"> = {\n';
  for (const [slug, format] of availableBySlug) {
    source += `  ${quote(slug)}: ${quote(format)},\n`;
  }
  source += "};\n";
  await Deno.writeTextFile(outPath, source);

  console.log(
    `Wrote ${availableBySlug.size} image-backed slugs to ${outPath}`,
  );
}
